// ===== Функции ==========================================================
{
function myFunc () { // объявление функции
    console.log('myFunc'); // действие функции
}

myFunc(); // вызов функции // консоль: myFunc

function myFunc2 (param) { // функция с параметром в круглых скобках (param, item, и т.д.) 
    console.log(param); // действие параметра функции
}

myFunc2('Алексей'); // в круглых скобках аргумент функции,
// т.е. значение, которое заменяет параметр // консоль: Алексей

}

// ====== Функциональные выражения ==========================================
// это по сути функция присвоенная переменной
{

const printMe = function() {
    console.log('printMe');
}

printMe(); // вызов функции // консоль: printMe

const printParam = function(a, b) { // функция с параметрами a и b
    console.log(a, b); // действие функции
}

printParam(10, 20); // вызов функции с аргументами - 10, 20
// консоль: вместо (a, b) получаем -  10 20

printParam('Андрей', 'Павел'); // вызов функции с аргументами - 'Андрей', 'Павел'
// консоль: вместо (a, b) получаем -  Андрей Павел

}

// ===== Возвращение функции с помощью return ==================================

{
function sum(a, b) { // функция с параметрами (a, b)
    return a + b; // return складывает параметры и возвращает результат
}

console.log(sum(10, 20)); // вызов функции с аргументами - 10, 20 в консоли
// функция выполнит действие сложения аргументов и выдаст результат
// консоль: 30

function sum2(a, b) {// функция с параметрами (a, b)
    let result = a + b; // объявление переменной со значением действия сложения
    return result; // возврат переменной с результатом действия
}

}

// ===== Параметр функции по умолчанию ========================================

{
function calc(a, b) {
    return (2 * (a + b));
}

console.log(calc(10, 20)); // вызов функции с аргументами - 10, 20 
// консоль: 60 - т.е. (2 * (10 + 20)) = 60

console.log(calc(5, 8)); // вызов функции с аргументами - 5, 8 
// консоль: 26 - т.е. (2 * (5 + 8)) = 26

console.log(calc(10)); // если вызвать функцию с одним аргументом - 10 
// консоль - получим NaN

function calc2(a, b = 0) { // для параметра b назначено значение по-умолчанию 0
    return (2 * (a + b));
}

console.log(calc2(10)); // теперь если аргумент один - 10, второй по-умолчанию будет 0
 // консоль: 20 - т.е. (2 * (10 + 0)) = 20

}
 
 // ===== REST параметр функции =================================================
 // это значит что функция может принимать
 // любое кол-во аргументов в виде массива

 {
 function collectThings(x, ...y) { // ...y - это REST параметр
// 1. у функции может быть только один REST параметр
// 2. REST параметр должен быть последним в цепочке

    console.log(x);
    console.log(y);
 }

 collectThings(1,2,3,4,5,6,7,8,9,10);
 // консоль: 1 - сначала покажет (x) 
 // консоль: [ 2, 3, 4, 5, 6, 7, 8, 9, 10 ] - затем остальные числа в виде массива (...y)

}

 // ===== Стрелочные функции ===============================================

{
 // синтаксис стрелочной функции

 const add = (a, b) => {
    return a + b;
 }

 // можно записать в одну строку
// если функция принимает 2 параметра и более (a, b, ...), то скобки обязательны
 const add2 = (a, b) => a + b; // убираются фигурные скобки {} и слово return

 const add3 = a => a + b; // если один параметр, то скобки () не нужно писать
 // также нужно писать без фигурных скобок {} и слова return

}

 // ===== Вложенные функции ==================================================

 {
    function outer() { // внешняя функция основная       
        console.log('outer'); // консоль: outer
        function inner() { // вложенная функция
            console.log('inner'); // консоль: inner
        }
        inner(); // вызов вложенной в основную функции
    };
    
    outer(); // вызов внешней и вложенной внутри функции
    // консоль: outer inner
    
 }

 // ===== Области видимости функции ===========================================

 {
    // ПРАВИЛА:
    // 1. Переменная, которая определена внутри функции
    //    не доступна за пределами этой функции
    // 2. Функция может получить доступ ко всем переменным
    //    внутри области в которой она определена
    // 3. Внешняя функция не может получить доступ к переменным
    //    определенным во вложенной в нее функции
    // 4. Вложенная функция может получить доступ ко всем переменным
    //    внешней функции в которой она находится

    // Пример к первому правилу
    function doSomething() {
        let x = 10;
        const y = 20;
        var z = 30;

        console.log(x, y, z);
    }
    
    doSomething(); // консоль: 10 20 30

    // console.log(x, y, z);

    // Если запустить console.log(x, y, z); за пределами функции
    // в которой определены данные переменные, то мы получим ошибку:
    // Uncaught ReferenceError: x is not defined at main.js:161:17

    // Пример к второму правилу
    let x = 10; // глобальная переменная
    const y = 20; // глобальная переменная
    var z = 30; // глобальная переменная

    function doSomething2() {
        console.log(x, y, z);
    }
    
    // Функция видит глобальные переменные без проблем
    // и может с ними работать
    doSomething2(); // консоль: 10 20 30
 }

// ===== Замыкания ==========================================================

{
// Замыкание - это ничто иное как внутренняя функция вложенная во внешнюю
// это значит, что вложенная функция имеет доступ к переменным внешней функции, а
// внешняя функция не имеет доступа к переменным во внутренней функции

// ПРИМЕР:

function outer(x) {
    function inner(y) { // Эта вложенная функция и есть замыкание
        return x + y;
    }
    return inner;    
}

const outerReturn = outer(10); // консоль: Undefined
// внешняя функция выполнила параметр х и остановилась
// 10 записалось в х вложенной функции

console.log(outerReturn(20)); // консоль: 30
// внешнее возвращаемое значение это внутрення функция
// 20 запишется в у и произойдет замыкание которое выведет результат 30

function firstLevelFunction() { // внешняя функция для функции secondLevelFunction() 
    let outerVar = "Outer"; // переменная внешней функции
    function secondLevelFunction() { // внутренняя функция - замыкание
      return `Inner ${outerVar}`; // получает доступ к переменной внешней функции
      // и возвращает её
    };
    return secondLevelFunction(); //внешняя функция возвращает вложенную функцию 
  }
  firstLevelFunction(); // результат: Inner Outer
  
}


